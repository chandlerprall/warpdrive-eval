# N+1 Query Detection & Reporting

**Status:** âœ… Implemented  
**Created:** December 19, 2024  
**Version:** 1.0

---

## ğŸ“‹ Table of Contents

1. [Overview](#overview)
2. [What is an N+1 Problem?](#what-is-an-n1-problem)
3. [How It Works](#how-it-works)
4. [Using the Debug Panel](#using-the-debug-panel)
5. [Example: Detecting N+1](#example-detecting-n1)
6. [Example: Fixing N+1](#example-fixing-n1)
7. [Architecture](#architecture)
8. [Configuration](#configuration)
9. [Technical Details](#technical-details)

---

## Overview

This project includes an **automatic N+1 query detection system** that monitors relationship fetches in real-time and alerts you when performance problems are detected. The system:

- âœ… **Tracks all relationship fetches** automatically via `ResolveRelationship` component
- âœ… **Detects N+1 patterns** using time-based bucketing (100ms windows)
- âœ… **Provides actionable recommendations** with specific fixes
- âœ… **Shows cache hit/miss** information to understand data flow
- âœ… **Non-intrusive** - monitoring doesn't affect app behavior

**Key Features:**
- Real-time monitoring with visual debug panel
- Time-based bucketing for accurate pattern detection
- Detailed fetch logs with timing information
- Before/after optimization comparison

---

## What is an N+1 Problem?

An **N+1 problem** occurs when you fetch a collection of resources, then make **N additional requests** to fetch related data for each item.

### Example Scenario

**The Problem:**
```
1. Fetch 10 posts              â†’ 1 request
2. For each post, fetch author â†’ 10 requests
3. For each post, fetch category â†’ 10 requests
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Total: 21 requests ğŸ˜±
```

**The Solution:**
```
1. Fetch 10 posts with ?include=author,category â†’ 1 request
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Total: 1 request âœ…
```

**Why It Matters:**
- **Performance**: 21 requests take ~2100ms vs 1 request taking ~100ms
- **Server load**: Each request requires server processing
- **Network latency**: Each request has round-trip overhead
- **User experience**: Faster page loads, smoother interactions

---

## How It Works

### 1. Automatic Tracking

Every time `ResolveRelationship` component fetches a relationship, it reports to the `RelationshipMonitor` service:

```javascript
// Automatically tracked:
- Relationship type (e.g., 'user')
- Relationship name (e.g., 'author')
- Parent resource (e.g., 'post#1')
- Timing (duration in ms)
- Cache status (hit or miss)
- URL fetched
```

### 2. Time-Based Bucketing

Fetches are grouped into **buckets** based on time:

```
Time:     0ms    50ms   100ms   [250ms gap]   400ms
Bucket:   â”œâ”€â”€â”€â”€ Bucket #1 â”€â”€â”€â”€â”€â”¤            â”œâ”€ Bucket #2 â”€â”€â”¤
Fetches:  F1 F2  F3     F4                   F5     F6
```

**Bucketing Rules:**
- **New bucket created** when gap between fetches > 100ms
- Each bucket analyzed independently
- Separates distinct page loads / user interactions

### 3. N+1 Detection

Within each bucket, the system:

1. **Groups fetches** by relationship type (e.g., all "author" fetches)
2. **Counts network requests** (ignores cache hits)
3. **Triggers N+1 warning** if count â‰¥ 3 of same type
4. **Generates recommendation** with specific fix

### 4. Visual Reporting

Results displayed in fixed debug panel at bottom of screen:

```
ğŸ“Š Relationship Monitor
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Total Buckets: 2
Active Patterns: 1 âš ï¸
Network Requests: 10
Cache Hits: 5
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â–¼ Bucket #1 (12:34:56.123) - âš ï¸ N+1 Detected
  
  âš ï¸ N+1 Pattern: author (type: user)
  Fetches: 10 network requests
  Parent: post (10 unique IDs)
  
  ğŸ’¡ Recommendation:
  Add ?include=author to your request builder
```

---

## Using the Debug Panel

### Opening the Panel

The **Relationship Monitor** button is fixed at the bottom of every page:

1. Click **"â–¶ Relationship Monitor"** to open
2. Panel expands to show summary and buckets
3. Click **"â–¼ Relationship Monitor"** to close

### Panel Sections

#### 1. Overview (Always Visible)

```
Total Buckets: 3         # Number of time windows tracked
Active Patterns: 1 âš ï¸    # N+1 warnings currently detected
Total Fetches: 15        # All relationship fetches
Network Requests: 10     # Actual HTTP requests
Cache Hits: 5 âœ…         # Data served from cache
Bucket Window: 100ms     # Time threshold
```

#### 2. Controls

- **Expand All**: Open all bucket details at once
- **Collapse All**: Close all buckets
- **Clear History**: Reset all tracking data (useful for testing)

#### 3. Bucket List

Each bucket shows:

**Header (Collapsed):**
```
â–¶ âš ï¸ Bucket #1 (12:34:56.123) â€¢ 11 fetches â€¢ 1 pattern(s)
```

**Details (Expanded):**
- **Time Range**: Start and end timestamps with duration
- **Summary**: Total fetches, network vs cache breakdown
- **Detected Patterns**: N+1 warnings with recommendations
- **Detailed Fetch Log**: Every fetch with timing and URLs

---

## Example: Detecting N+1

### Scenario: Posts List Page

**Route:** `/posts` (shows 10 posts with authors)

**What Happens:**

1. Navigate to `/posts`
2. Page fetches 10 posts
3. Each post's `<ResolveRelationship @resource={{post.author}}>` fetches author
4. 10 author fetches happen within ~500ms â†’ Same bucket
5. Debug panel shows **âš ï¸ N+1 Detected**

**Debug Panel Output:**

```
â–¼ Bucket #1 (12:34:56.123) - âš ï¸ N+1 Detected
  Time Range: 12:34:56.123 - 12:34:56.623 (500ms)
  Total Fetches: 10 (10 network, 0 cache)
  
  âš ï¸ N+1 Pattern Detected
  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  Relationship: author (type: user)
  Fetches: 10 network requests
  Parent: post (10 unique IDs)
  
  ğŸ’¡ Recommendation:
  Add ?include=author to your request builder to reduce 10 requests to 1
  
  ğŸ” Detailed Fetch Log:
  â–¼ author (user) - 10 fetches
    1. post#1.author â†’ user (45ms) [network]
       /api/users/1
    2. post#2.author â†’ user (42ms) [network]
       /api/users/2
    ... (8 more)
```

**What This Tells You:**
- âœ… Problem identified: 10 separate author fetches
- âœ… Solution provided: Use `?include=author`
- âœ… Impact quantified: 10 requests â†’ 1 request
- âœ… Timing shown: 500ms of sequential fetches

---

## Example: Fixing N+1

### Step 1: Identify the Builder

The recommendation tells you to modify your request builder. For the posts list, that's `app/builders/posts.js`:

### Step 2: Add Include Parameter

**Before (N+1):**

```javascript
// app/builders/posts.js
export function queryPublishedPosts() {
  return {
    url: apiURL('/posts', { 
      'filter[status]': 'published'
    }),
    method: 'GET',
    headers: new Headers({ 'Accept': 'application/vnd.api+json' })
  };
}
```

**After (Optimized):**

```javascript
// app/builders/posts.js
export function queryPublishedPosts() {
  return {
    url: apiURL('/posts', { 
      'filter[status]': 'published',
      include: 'author,category'  // âœ… Add this
    }),
    method: 'GET',
    headers: new Headers({ 'Accept': 'application/vnd.api+json' })
  };
}
```

### Step 3: Verify the Fix

1. Navigate away from `/posts`
2. Click **"Clear History"** in debug panel
3. Navigate back to `/posts`
4. Open debug panel

**Expected Result:**

```
â–¼ Bucket #1 (12:35:10.456) - âœ… Optimal
  Time Range: 12:35:10.456 - 12:35:10.502 (46ms)
  Total Fetches: 0 network (all data from initial request)
  Cache Hits: 10
  
  âœ… No patterns detected - optimal performance
  
  ğŸ” Detailed Fetch Log:
  â–¼ author (user) - 10 fetches
    1. post#1.author â†’ user (2ms) [cache hit] âœ…
    2. post#2.author â†’ user (1ms) [cache hit] âœ…
    ... (8 more - all cache hits)
```

**What Changed:**
- âŒ Before: 10 network requests, 500ms total
- âœ… After: 0 network requests, 46ms total (all cache hits!)
- ğŸ‰ **10x faster, 90% fewer requests**

### Why This Works

**JSON:API Include Parameter:**

When you add `?include=author,category`:

1. API returns posts with **included authors and categories** in one response
2. WarpDrive automatically caches all included resources
3. `ResolveRelationship` finds authors in cache â†’ no fetch needed
4. Debug panel shows cache hits instead of network requests

---

## Architecture

### Component Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    User Navigates                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   Route Model    â”‚
              â”‚   (fetch posts)  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚      Template           â”‚
          â”‚   (render posts list)   â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   ResolveRelationship Component  â”‚
    â”‚   (for each post.author)         â”‚
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚              â”‚
           â”‚ â‘ fetch()     â”‚ â‘¡trackFetch()
           â”‚              â”‚  (via next())
           â–¼              â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   API    â”‚   â”‚ Relationship     â”‚
    â”‚ /users/1 â”‚   â”‚ Monitor Service  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â”‚ â‘¢analyzePatterns()
                          â”‚
                          â–¼
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚  Bucket with   â”‚
                  â”‚  Pattern Data  â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â”‚ Reactive
                          â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ RelationshipDebugPanel    â”‚
            â”‚ (displays results)        â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Flow

1. **Component renders** â†’ Needs relationship data
2. **ResolveRelationship** â†’ Calls `resource.fetch()` if not cached
3. **Tracking (async)** â†’ Reports fetch to monitor service via `next()`
4. **Service buckets** â†’ Groups fetch into time-based bucket
5. **Analysis** â†’ Detects patterns when bucket updated
6. **Reactive UI** â†’ Debug panel automatically updates

### Key Files

```
app/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ resolve-relationship.gjs        # Instrumented component
â”‚   â””â”€â”€ relationship-debug-panel.gjs    # Visual debug panel
â”œâ”€â”€ services/
â”‚   â””â”€â”€ relationship-monitor.js         # Tracking & analysis service
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ application.gjs                 # Panel integration
â”‚   â”œâ”€â”€ posts/
â”‚   â”‚   â”œâ”€â”€ index.gjs                   # Uses parent args
â”‚   â”‚   â””â”€â”€ detail.gjs                  # Uses parent args
â”‚   â””â”€â”€ users/
â”‚       â””â”€â”€ detail.gjs                  # Uses parent args
â””â”€â”€ styles/
    â””â”€â”€ app.css                         # Debug panel styles
```

---

## Configuration

### Service Configuration

Edit `app/services/relationship-monitor.js`:

```javascript
export default class RelationshipMonitorService extends Service {
  bucketThreshold = 100;  // ms - time gap to create new bucket
  maxBuckets = 50;        // Keep last N buckets in memory
  n1Threshold = 3;        // Min fetches to trigger N+1 warning
  // ...
}
```

**Options:**

| Setting | Default | Description |
|---------|---------|-------------|
| `bucketThreshold` | 100ms | Time gap to create new bucket. Increase for slower pages. |
| `maxBuckets` | 50 | History limit. Prevents memory leaks. |
| `n1Threshold` | 3 | Min fetches to warn. Lower = more sensitive. |

### Component Configuration

`ResolveRelationship` accepts optional args for richer tracking:

```gjs
<ResolveRelationship 
  @resource={{post.author}}
  @parentType="post"        {{! Optional: parent resource type }}
  @parentId={{post.id}}     {{! Optional: parent resource ID }}
  as |author|
>
  {{author.displayName}}
</ResolveRelationship>
```

**Benefits of parent args:**
- Better pattern detection (knows which posts triggered fetches)
- More detailed logs (shows `post#1.author â†’ user#123`)
- Useful for debugging complex relationships

---

## Technical Details

### Time-Based Bucketing Strategy

**Why time-based instead of route-based?**

Modern frontend apps are dynamic:
- Components mount/unmount at any time
- Data fetched outside route transitions
- Same route can trigger different patterns based on state

**Time-based advantages:**
- âœ… **Route-agnostic**: Works regardless of routing structure
- âœ… **Simpler logic**: No router lifecycle hooks needed
- âœ… **More accurate**: Captures actual temporal clustering
- âœ… **Better granularity**: Multiple patterns per page load
- âœ… **Dynamic-friendly**: Handles lazy loading, user interactions

**Algorithm:**

```javascript
trackFetch(fetchData) {
  const now = fetchData.timestamp;
  const gap = now - this.lastFetchTime;
  
  if (gap > 100ms) {
    // Create new bucket
    this.buckets.unshift({
      id: `bucket-${now}`,
      startTime: now,
      fetches: [fetchData],
      patterns: []
    });
  } else {
    // Add to current bucket
    this.buckets[0].fetches.push(fetchData);
  }
  
  this.analyzePatterns(this.buckets[0]);
}
```

### N+1 Detection Algorithm

```javascript
analyzePatterns(bucket) {
  // 1. Group fetches by relationship type
  const groups = new Map();
  
  for (const fetch of bucket.fetches) {
    if (fetch.cacheHit) continue; // Ignore cache hits
    
    const key = `${fetch.relationshipType}:${fetch.relationshipName}`;
    groups.get(key).fetches.push(fetch);
  }
  
  // 2. Detect N+1 patterns
  for (const group of groups.values()) {
    if (group.fetches.length >= 3) {
      bucket.patterns.push({
        type: 'n+1',
        relationshipName: group.relationshipName,
        count: group.fetches.length,
        suggestion: `Add ?include=${relationshipName}`
      });
    }
  }
}
```

**Key Points:**
- Cache hits excluded (not network requests)
- Groups by type + name (different relationships tracked separately)
- Configurable threshold (default: 3 fetches)
- Generates actionable suggestions

### Runloop Scheduling

**Problem:** Updating tracked properties during render causes Ember assertion errors.

**Solution:** Wrap tracking in `next()` from `@ember/runloop`:

```javascript
// app/components/resolve-relationship.gjs
trackFetch(data) {
  next(() => {
    this.relationshipMonitor.trackFetch(data);
  });
}
```

**Why this works:**
- `next()` schedules work for after current render cycle
- Monitoring data doesn't need to be immediately available
- Prevents "attempted to update after use" errors
- Safe pattern for non-critical side effects

### Performance Considerations

**Overhead:**
- Tracking: O(1) per fetch (array push)
- Analysis: O(n) where n = fetches per bucket (typically < 100)
- Memory: ~50 buckets Ã— ~20 fetches = ~1000 tracked events max

**Impact:**
- Minimal: Tracking happens asynchronously (next runloop)
- Non-blocking: Doesn't affect app rendering
- Self-limiting: FIFO with 50 bucket cap

**Production:**
- Leave enabled: Helps catch regressions
- Or disable: Wrap in `if (config.environment !== 'production')`

---

## Best Practices

### 1. Always Use `?include` for Lists

When displaying a list with relationships, **always include related data**:

```javascript
// âœ… Good: Include relationships upfront
queryPublishedPosts() {
  return {
    url: apiURL('/posts', { 
      include: 'author,category'
    })
  };
}

// âŒ Bad: Lazy-load each relationship
queryPublishedPosts() {
  return {
    url: apiURL('/posts', {})
  };
  // Results in N+1 when rendering
}
```

### 2. Be Selective on Detail Pages

Detail pages typically show one resource - consider if includes are needed:

```javascript
// Detail page: post + author + category
// âœ… Include if always displayed
findPost(id) {
  return {
    url: apiURL(`/posts/${id}`, { 
      include: 'author,category'
    })
  };
}

// âŒ Don't include if rarely used
findPost(id) {
  return {
    url: apiURL(`/posts/${id}`, { 
      include: 'author,category,tags,comments,likes'
    })
  };
  // Over-fetching if user rarely scrolls to comments
}
```

### 3. Monitor After Changes

After modifying builders or adding new relationships:

1. Clear debug panel history
2. Navigate through affected pages
3. Check for new N+1 warnings
4. Fix before merging

### 4. Use Parent Args for Complex Debugging

When tracking isn't clear, add parent metadata:

```gjs
<ResolveRelationship 
  @resource={{comment.author}}
  @parentType="comment"
  @parentId={{comment.id}}
  as |author|
>
```

Helps identify: "Which comments triggered these fetches?"

---

## Troubleshooting

### Panel Shows No Data

**Symptoms:** Panel opens but shows "No relationship fetches tracked yet"

**Causes:**
1. Haven't navigated to page with relationships
2. All relationships served from cache (looks like no fetches)
3. Component not using `ResolveRelationship`

**Solutions:**
1. Navigate to `/posts` or `/users/:id`
2. Check "Cache Hits" in overview - might be working!
3. Ensure templates use `<ResolveRelationship>` for relationship access

### False Positives

**Symptoms:** N+1 warning but seems incorrect

**Causes:**
1. Threshold too low (3 fetches might be legitimate)
2. Different contexts lumped together
3. Cache warming scenarios

**Solutions:**
1. Increase `n1Threshold` in service (e.g., to 5)
2. Check parent IDs - are they actually the same pattern?
3. Consider if warning is valid (often still worth optimizing)

### Panel Doesn't Update

**Symptoms:** Navigate but bucket count doesn't increase

**Causes:**
1. Service not injected properly
2. Runloop issue (tracking not scheduled)
3. Browser DevTools paused execution

**Solutions:**
1. Check browser console for errors
2. Verify `@service relationshipMonitor` in component
3. Close/reopen DevTools, refresh page

---

## Future Enhancements

Potential improvements for future iterations:

### v2.0 Features
- [ ] **Keyboard shortcut** to toggle panel (e.g., `Ctrl+Shift+R`)
- [ ] **Persist state** via localStorage (panel open/closed)
- [ ] **Export reports** as JSON or CSV
- [ ] **Historical comparison** ("50% faster than last week")

### v3.0 Features
- [ ] **Browser extension** with dedicated DevTools panel
- [ ] **Performance budgets** (fail CI if N+1 detected)
- [ ] **Automatic optimization** suggestions via AI
- [ ] **Visual query builder** for `?include` parameters

### Alternative Approaches
- [ ] **Integration with LoggingHandler** for unified debugging
- [ ] **Batch detection** (multiple relationships in one pattern)
- [ ] **Intelligent caching** suggestions based on patterns

---

## Contributing

Found a bug or have an idea? Contributions welcome!

### Adding New Pattern Types

Currently detects: `n+1`

To add more patterns (e.g., circular fetches, over-fetching):

1. Edit `analyzePatterns()` in `relationship-monitor.js`
2. Add pattern detection logic
3. Update debug panel to display new pattern type
4. Add tests to `tests/unit/services/relationship-monitor-test.js`

### Improving Suggestions

Suggestions generated in `generateSuggestion()`:

```javascript
generateSuggestion(group) {
  const { relationshipName, fetches } = group;
  const count = fetches.length;
  
  // Customize based on relationship type, count, context
  return `Add ?include=${relationshipName} to reduce ${count} requests to 1`;
}
```

Ideas:
- Link to specific file/line number
- Show before/after code diff
- Estimate performance impact (ms saved)

---

## References

### WarpDrive Documentation
- [Relationships](../kb/the-manual/schemas/relational-fields.md)
- [Request Builders](../kb/the-manual/requests/builders.md)
- [Caching](../kb/the-manual/caching/)

### JSON:API Specification
- [Inclusion of Related Resources](https://jsonapi.org/format/#fetching-includes)
- [Sparse Fieldsets](https://jsonapi.org/format/#fetching-sparse-fieldsets)

### Project Documentation
- [Cold Boot Guide](./coldboot.md) - Complete project state
- [Iteration Plan](./plan.md) - Roadmap and iterations

---

## License

This N+1 detection system is part of the WarpDrive Evaluation project and follows the same license as the parent project.

---

**Questions?** Check the [Cold Boot Guide](./coldboot.md) or explore the codebase!

**Happy optimizing!** ğŸš€

